# -*- coding: utf-8 -*-
"""KrylovMethodNewest.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VuDSNucaqjF_LYuAp_iNrr5QryfmHt7A
"""
import numpy as np
import scipy
from qiskit.quantum_info import SparsePauliOp
def construct_hamiltonian(j1, j2, grid):
  def nearest_neighbor(grid, i, j):
    i, j = i % len(grid[0]), j % len(grid)
    look_at = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    result = []
    for element in look_at:
      dx, dy = element
      result.append([(i + dx) % len(grid[0]), (j + dy) % len(grid)])
    return result

  def next_nearest_neighbor(grid, i, j):
    look_at = [[1, 1], [1, -1], [-1, 1], [-1, -1]]
    result = []
    for element in look_at:
      dx, dy = element
      result.append([(i + dx) % len(grid[0]), (j + dy) % len(grid)])
    return result

  def generate_dot_product(grid, term, idxA, idxB):
    operation_template = ['I' for element in range(len(grid[0]) * len(grid))]
    dot_product = SparsePauliOp(('I' * len(grid[0]) * len(grid)), coeffs=[0])
    for direction in ['X', 'Y', 'Z']:
      operation = operation_template
      operation[idxA], operation[idxB] = direction, direction
      dot_product += SparsePauliOp("".join(operation), coeffs=[term])
    return dot_product


  hamilonian = SparsePauliOp(('I' * len(grid[0]) * len(grid)), coeffs=[0])
  for i in range(len(grid[0])):
    for j in range(len(grid)):
      n_neighbors = nearest_neighbor(grid, i, j)
      nn_neighbors = next_nearest_neighbor(grid, i, j)

      for neighbor in n_neighbors:
        idxA = (j * len(grid)) + i
        idxB = (neighbor[1] * len(grid)) + neighbor[0]
        hamilonian += generate_dot_product(grid, j1, idxA, idxB)
      for neighbor in nn_neighbors:
        idxA = (j * len(grid)) + i
        idxB = (neighbor[1] * len(grid)) + neighbor[0]
        hamilonian += generate_dot_product(grid, j2, idxA, idxB)

  return hamilonian.simplify()

from scipy.optimize import minimize
itr = 0
total = 0
def cost_func(x0, ansatz, H, estimator):
    global itr
    global pm
    x0_new = np.append(x0, [0 for i in range(ansatz.num_parameters - len(x0))])
    ansatz_copy = ansatz.assign_parameters(x0_new)
    energy = estimator.run(ansatz_copy, H).result().values[0]
    itr += 1
    return energy

import random
import copy
import numpy as np
from scipy.optimize import dual_annealing
from qiskit.circuit.library import RealAmplitudes, EfficientSU2, TwoLocal, PauliTwoDesign
from qiskit_algorithms.optimizers import SPSA, COBYLA, AQGD, NFT, SLSQP, IMFIL, BOBYQA, UMDA
from qiskit.circuit.library import RZZGate, RZGate
import qiskit
import numpy as np
from qiskit.primitives import Estimator, Sampler
from qiskit import QuantumCircuit
from qiskit.circuit.library import PauliEvolutionGate
from qiskit.compiler import transpile
from qiskit_algorithms.gradients import ParamShiftEstimatorGradient
from qiskit.circuit import QuantumCircuit, Parameter
import random
estimator = qiskit.primitives.Estimator(options={"shots": None, "approximation": True})

def run_vqe(ham):
    global energy_values, steps_values
    global ansatz, average_gradient, averages, total_losses, total_averages, sampled_grads, estimator, historic_gradients, hamiltonian_temp, best_so_far, value_best
    hamiltonian_temp = ham
    hamiltonian = ham
    def minimize_func(new_parameters):
        global ansatz, hamiltonian_temp, estimator
        energy = (cost_func(new_parameters, ansatz, hamiltonian_temp, estimator))
        return energy.real


    ansatz = TwoLocal(16, 'rx', 'cz', entanglement='sca', reps=3)
    #print(ansatz.num_parameters)
    #print(ansatz_local.num_parameters)
    bounds = [(0, 2 * np.pi)] * ansatz.num_parameters
    optimizer = NFT(maxiter=100)
    initial_parameters =  2 * np.random.random(ansatz.num_parameters) * np.pi
    res = optimizer.minimize(minimize_func, initial_parameters, bounds=bounds)

    new_ansatz = ansatz.assign_parameters(res.x)
    new_ansatz.remove_final_measurements()  # no measurements allowed
    from qiskit.quantum_info import Statevector
    statevector = Statevector(new_ansatz)

    return statevector


def modified_gram_schmidt(V):
    n, k = V.shape
    Q = np.zeros((n, k), dtype=complex)  # Orthogonalized vectors
    for i in range(k):
        q = V[:, i]
        for j in range(i):
            q -= np.vdot(Q[:, j], V[:, i]) * Q[:, j]
        Q[:, i] = q / np.linalg.norm(q)
    return Q

import math
import numpy as np
import scipy as sp

import math
import numpy as np
import scipy as sp
import matplotlib.pylab as plt
import warnings
warnings.filterwarnings('ignore')

from qiskit.quantum_info import SparsePauliOp, Operator
from qiskit.circuit import Parameter
from qiskit import QuantumCircuit, QuantumRegister, transpile
from qiskit.circuit.library import PauliEvolutionGate
from qiskit.synthesis import SuzukiTrotter, MatrixExponential
from qiskit.providers.fake_provider import Fake20QV1
from qiskit.primitives import Estimator

import scipy.sparse as sp

def neel_order(dim):
    L = dim[0] * dim[1]
    neel_op = SparsePauliOp(('I' * L), coeffs=[0])

    for i in range(L):
        x, y = i % dim[0], i // dim[0]
        sign = (-1) ** (x + y)
        label = ['I'] * L
        label[i] = 'Z'
        neel_op += SparsePauliOp(''.join(label), coeffs=[sign])

    neel_op = neel_op.simplify()
    neel_op /= L  # Normalize the NÃ©el operator

    return (neel_op @ neel_op).simplify()

def dimer_order(dim):
    Lx, Ly = dim
    num_spins = Lx*Ly
    dimer_op = SparsePauliOp(('I' * num_spins), coeffs=[0])
    normalization = 0

    for x in range(0, Lx//2, 2):
        for y in range(Ly):
            i = y * Ly + x
            j = ((x + 1) % Lx) + y * Ly
            sign = (-1)**(x)
            label = ['I'] * num_spins
            label[i] = label[j] = 'X'
            dimer_op += sign * SparsePauliOp(''.join(label), coeffs=[sign])
            label[i] = label[j] = 'Y'
            dimer_op += sign * SparsePauliOp(''.join(label), coeffs=[sign])
            label[i] = label[j] = 'Z'
            dimer_op += sign * SparsePauliOp(''.join(label), coeffs=[sign])
            normalization += 1

    dimer_op.simplify()

    for x in range(0, Lx//2, 3):
        for y in range(Ly):
            i = y * Ly + x
            j = ((x + 2) % Lx) + y * Ly
            sign = (-1)**(x)
            label = ['I'] * num_spins
            label[i] = label[j] = 'X'
            dimer_op += sign * SparsePauliOp(''.join(label), coeffs=[sign])
            label[i] = label[j] = 'Y'
            dimer_op += sign * SparsePauliOp(''.join(label), coeffs=[sign])
            label[i] = label[j] = 'Z'
            dimer_op += sign * SparsePauliOp(''.join(label), coeffs=[sign])
            normalization += 1

    dimer_op.simplify()

    for y in range(0, Ly//2, 2):
        for x in range(Lx):
            i = y * Ly + x
            j = ((y + 1) % Ly)*Ly + x
            sign = (-1)**(y)
            label = ['I'] * num_spins
            label[i] = label[j] = 'X'
            dimer_op += sign * SparsePauliOp(''.join(label), coeffs=[sign])
            label[i] = label[j] = 'Y'
            dimer_op += sign * SparsePauliOp(''.join(label), coeffs=[sign])
            label[i] = label[j] = 'Z'
            dimer_op += sign * SparsePauliOp(''.join(label), coeffs=[sign])
            normalization += 1

    dimer_op.simplify()

    for y in range(0, Ly//2, 3):
        for x in range(Lx):
            i = y * Ly + x
            j = ((y + 2) % Ly)*Ly + x
            sign = (-1)**(y)
            label = ['I'] * num_spins
            label[i] = label[j] = 'X'
            dimer_op += sign * SparsePauliOp(''.join(label), coeffs=[sign])
            label[i] = label[j] = 'Y'
            dimer_op += sign * SparsePauliOp(''.join(label), coeffs=[sign])
            label[i] = label[j] = 'Z'
            dimer_op += sign * SparsePauliOp(''.join(label), coeffs=[sign])
            normalization += 1

    dimer_op.simplify()
    dimer_op /= normalization
    return (dimer_op @ dimer_op).simplify()

def spin_order(dim):
    L = dim[0] * dim[1]
    spin_corr = SparsePauliOp(('I' * L), coeffs=[0])

    for i in range(L):
        for j in range(i+1, L):
            x1, y1 = i % dim[0], i // dim[0]
            x2, y2 = j % dim[0], j // dim[0]

            if abs(x1 - x2) + abs(y1 - y2) == 1:  # Nearest neighbors
                label = ['I'] * L
                label[i] = 'Z'
                label[j] = 'Z'
                spin_corr += SparsePauliOp(''.join(label), coeffs=[1])

    spin_corr = spin_corr.simplify()
    spin_corr /= L  # Normalize the spin correlation operator

    return spin_corr

def spin_correlation(dim, max_distance=None):
    L = dim[0] * dim[1]
    spin_corr = SparsePauliOp(('I' * L), coeffs=[0])

    for i in range(L):
        for j in range(i+1, L):
            x1, y1 = i % dim[0], i // dim[0]
            x2, y2 = j % dim[0], j // dim[0]

            distance = abs(x1 - x2) + abs(y1 - y2)
            if max_distance is None or distance <= max_distance:
                label = ['I'] * L
                label[i] = 'Z'
                label[j] = 'Z'
                coeff = 1 / (distance ** 2)  # Weight coefficient by inverse square of distance
                spin_corr += SparsePauliOp(''.join(label), coeffs=[coeff])

    spin_corr = spin_corr.simplify()
    spin_corr /= L  # Normalize the spin correlation operator

    return spin_corr

dim = [4,4]
neel_ham = neel_order(dim).to_matrix(sparse=True)
dimer_ham = dimer_order(dim).to_matrix(sparse=True)
spin_ham = spin_order(dim).to_matrix(sparse=True)
spin_corr_ham = spin_correlation(dim).to_matrix(sparse=True)

#local, global, neel, dimer
expectations = [spin_ham, spin_corr_ham, neel_ham, dimer_ham]

import numpy as np
import scipy.sparse as sp

# Function to perform matrix power for a sparse matrix
def sparse_matrix_power(matrix, power):
    result = matrix
    for _ in range(power - 1):
        result = result @ matrix
    return result


def generate_krylov_vectors(sparse_H, v_csc, krylov_dim=15):
    """
    Generate a Krylov basis using Chebyshev polynomials and orthonormalize them using the Gram-Schmidt process.
    sparse_H: Hamiltonian matrix (sparse)
    v_csc: Initial vector (sparse)
    krylov_dim: Dimension of the Krylov subspace
    """
    n = sparse_H.shape[0]
    V = np.zeros((n, krylov_dim), dtype=complex)
    
    # Ensure v0 is a dense vector
    if sp.issparse(v_csc):
        v0 = v_csc.toarray().flatten()
    else:
        v0 = v_csc
    
    V[:, 0] = v0 / np.linalg.norm(v0)
    
    if krylov_dim > 1:
        V[:, 1] = sparse_H.dot(V[:, 0])
        V[:, 1] /= np.linalg.norm(V[:, 1])

    for j in range(2, krylov_dim):
        temp = sparse_H.dot(V[:, j - 1])
        V[:, j] = 2 * (temp/np.linalg.norm(temp)) - V[:, j - 2]
        V[:, j] /= np.linalg.norm(V[:, j])
    
    return V

import numpy as np
import scipy.sparse as sp

def generate_krylov_vectors(sparse_H, v_csc, krylov_dim=15):
    """
    Generate a Krylov basis using powers of the Hamiltonian and orthonormalize them using the Gram-Schmidt process.
    
    Parameters:
    sparse_H (scipy.sparse matrix): Hamiltonian matrix (sparse)
    v_csc (scipy.sparse vector or ndarray): Initial vector (sparse or dense)
    krylov_dim (int): Dimension of the Krylov subspace
    
    Returns:
    ndarray: Matrix with Krylov basis vectors as columns
    """
    n = sparse_H.shape[0]
    V = np.zeros((n, krylov_dim), dtype=complex)
    
    # Ensure v0 is a dense vector
    if sp.issparse(v_csc):
        v0 = v_csc.toarray().flatten()
    else:
        v0 = v_csc
    
    V[:, 0] = v0 / np.linalg.norm(v0)
    
    for j in range(1, krylov_dim):
        print("Krylov Vector: ", j)
        V[:, j] = sparse_H.dot(V[:, j - 1])
        V[:, j] -= V[:, :j] @ (V[:, :j].conj().T @ V[:, j])  # Gram-Schmidt orthonormalization
        V[:, j] /= np.linalg.norm(V[:, j])
    
    return V


def run_experiment(j2_j1, gram_schmidt=True):
    global expectations
    H_op = construct_hamiltonian(1.0, j2_j1, [[1/2 for _ in range(4)] for _ in range(4)])
    H_op = H_op.simplify()

    sparse_H = H_op.to_matrix(sparse=True)
    estimator = qiskit.primitives.Estimator(options={"shots": None, "approximation": True})
    #starting_vector = run_vqe(H_op)
    starting_vector = np.random.rand(2**16) + 1.0j * np.random.rand(2**16)
    starting_vector /= np.linalg.norm(starting_vector)

    from scipy.sparse.linalg import eigs
    eigvals_g, eigvecs_g = scipy.sparse.linalg.eigs(sparse_H, k=5)

    # Reshape starting vector to match Hamiltonian dimensions
    v = np.array(starting_vector).flatten()
    v_csc = sp.csc_matrix(v).T

    krylov_vectors = generate_krylov_vectors(sparse_H, v_csc)

    # Ensure all vectors are column vectors for stacking
    dense_K_matrix = np.column_stack(krylov_vectors)
    if gram_schmidt:
        K_matrix = modified_gram_schmidt(dense_K_matrix)
    else:
        K_matrix = dense_K_matrix


    K_matrix = K_matrix.T
    HK_matrix = sparse_H.dot(K_matrix)
    krylov_dim = K_matrix.shape[1]
    H_matrix_krylov = np.zeros((krylov_dim, krylov_dim), dtype=complex)

    for i in range(krylov_dim):
        for j in range(krylov_dim):
            element = K_matrix[:, i].conj().T.dot(HK_matrix[:, j])
            H_matrix_krylov[i, j] = element if np.isscalar(element) else element[0, 0]

    S_matrix_krylov = (K_matrix.conj().T).dot(K_matrix)
    #print(S_matrix_krylov)

    from scipy.linalg import eigh

    gnd_en_circ_est_list = []
    last_one = None
    for d in range(1, krylov_dim + 1):
        # Solve generalized eigenvalue problem using scipy
        eigvals, eigvecs = eigh(H_matrix_krylov[:d, :d], S_matrix_krylov[:d, :d] + 1e-12 * np.eye(d))
        gnd_en_circ_est = eigvals[0]
        gnd_en_circ_est_list.append(gnd_en_circ_est)
        if(d == krylov_dim):
            print('The estimated ground state energy is: ', gnd_en_circ_est, " Krylov Dim: ", d)
        last_one = eigvecs[:, 0]

    expectation_set = []
    for expectation in expectations:
        # Initialize the Hermitian matrix H_matrix_krylov of dimension krylov_dim x krylov_dim
        expectation_matrix_krylov = np.zeros((krylov_dim, krylov_dim), dtype=complex)

        # Compute the upper triangular part of the matrix
        for i in range(krylov_dim):
            for j in range(krylov_dim):
                element = K_matrix[:, i].conj().T.dot(expectation.dot(K_matrix[:, j]))
                expectation_matrix_krylov[i, j] = element if np.isscalar(element) else element[0, 0]
        vector = np.array(last_one)
        expectation_set.append(vector.conj().dot(expectation_matrix_krylov.dot(vector)))
    return expectation_set

j2_j1_points = [0,0.1,0.2,0.3,0.5,0.56,0.58,0.7,0.8,0.9,1.0]
for j2_j1_choice in j2_j1_points:
    for choice in [False]:
        print(f"Running: {j2_j1_choice} with Orthogonalization: {choice}")
        values = None
        for _ in range(3):
            expectation_values = run_experiment(j2_j1_choice, choice)
            if values is None:
                values = np.array(expectation_values) / 3
            else:
                values += np.array(expectation_values) / 3
        print(values)